---
layout: post
title: TheHole
date: 2022-03-23 14:05
summary: Let's try to leak TheHole
meta_robots: noindex, nofollow
---

## Environments

```
everyyy@baddell:/work/v8/220317_master/v8$ git rev-parse HEAD
e62f556862624103ea1da5b9dcef9b216832033b
everyyy@baddell:/work/v8/220317_master/v8$ git describe --contains
10.1.124~1
everyyy@baddell:/work/v8/220317_master/v8$
```

## TheHole

38003에서 힌트를 얻어서 시작.

**src/builtins/builtins-collections-gen.cc** 를 보면 TheHoleConstant() 함수를 통해 TheHole 값을 사용하고 있음. 해당 함수는 **src/codegen/code-stub-assembler.cc** 에서 매크로를 통해 생성된 것.

**src/codegen/code-stub-assembler.cc**
```cpp
#define HEAP_CONSTANT_ACCESSOR(rootIndexName, rootAccessorName, name)        \
  TNode<std::remove_pointer<std::remove_reference<decltype(                  \
      std::declval<ReadOnlyRoots>().rootAccessorName())>::type>::type>       \
      CodeStubAssembler::name##Constant() {                                  \
    return UncheckedCast<std::remove_pointer<std::remove_reference<decltype( \
        std::declval<ReadOnlyRoots>().rootAccessorName())>::type>::type>(    \
        LoadRoot(RootIndex::k##rootIndexName));                              \
  }
HEAP_IMMUTABLE_IMMOVABLE_OBJECT_LIST(HEAP_CONSTANT_ACCESSOR)
#undef HEAP_CONSTANT_ACCESSOR
```

**src/codegen/code-stub-assembler.h**
```cpp
#define HEAP_IMMUTABLE_IMMOVABLE_OBJECT_LIST(V)                              \
...
  V(TheHoleValue, the_hole_value, TheHole)                                   \
...

...
#define HEAP_IMMOVABLE_OBJECT_LIST(V)   \
  HEAP_MUTABLE_IMMOVABLE_OBJECT_LIST(V) \
  HEAP_IMMUTABLE_IMMOVABLE_OBJECT_LIST(V)
```

"TheHole" 과 "the_hole_value" 를 키워드로 소스코드 리파지토리 대상 전체 키워드 검색해서 훑어보기로 하자.

아니면... --background-index=true 옵션 줘서 인덱싱을 다 한듯한데... reference를 찾아서 볼까.

일단 전체적인 감을 잡기 위해 키워드 검색부터 훑어보자.

```cpp
src/heap/setup-heap-internal.cc

bool Heap::CreateInitialMaps() {
                    ...
  set_the_hole_value(Oddball::cast(obj));
  Oddball::cast(obj).set_kind(Oddball::kTheHole);
                    ...

void Heap::CreateInitialObjects() {
                    ...
  // Initialize the_hole_value.
  Oddball::Initialize(isolate(), factory->the_hole_value(), "hole",
                      factory->hole_nan_value(), "undefined",
                      Oddball::kTheHole);
                    ...

```

TheHole 이 초기화되는 코드인 듯.



### TheHole이 쓰이는 곳들

배열의 빈 element를 나타낼 때
- 이후 이를 접근하는 다양한 코드 패스들에 대해 TheHole을 검증하는 루틴이 존재함
- TheHole을 검증하지 않고 접근하는 코드 패스가 있는지 찾아 볼 필요가 있음, 이는 (당연하게도) TheHole 키워드 검색으로 발견되지 않으므로 좀 더 수고스러운 코드 분석이 필요할 것으로 생각됨.
- map, set, weakmap 등 collection 객체에서 삭제된 키(및 값)를 TheHole로 나타냄(src/builtins/builtins-collections-gen.cc)
- src/builtins/builtins-constructor-gen.cc, prototype(아니면 initial map?)에 TheHole이 쓰여지는 경우가 있는 듯
- src/builtins/builtins-internal-gen.cc, Dictionary의 경우에도 Delete 시(아마도 property?) TheHole을 씀
- src/builtins/builtins-internal-gen.cc, TF_BUILTIN(AdaptorWithBuiltinExitFrame), 의미 분석 필요 
- ** exception의 pending message가 clear되어 TheHole이 유출될 가능성이 있었던 듯? (src/builtins/builtins-iterator-gen.cc 참고), https://bugs.chromium.org/p/v8/issues/detail?id=12439 요 링크 참고해보자
- Promise(tq 파일들) 관련 코드들에서도 좀 보임...
- src/builtins/.../builtins-....cc 에 구현된 로우 레벨 코드에서도 사용되는 경우가 여럿 있으며(RootIndex::kTheHoleValue) 각각 사용되는 경우마다 분석이 필요할 듯. 이는 나중에 분석을 하긴 해야 할 듯. (어려워보임)
- compiler 에서는 Type::Hole(), OddballType::kHole, jsgraph->TheHoleConstant() 형태 등으로 사용됨. compiler 에서의 TheHole 사용은 나중에 따로 모아서 정리해보자
- ** scheduled_exception 관련 
- 인터프리터에서 BytecodeArrayBuilder& BytecodeArrayBuilder::LoadTheHole() 와 같은 경우에도 쓰임. Interpreter에서 쓰이는 경우도 언젠간 봐야 할지도... 인터프리터 자체에 대한 이해가 필요해서 많이 어려울 듯. 
- maglev(`void MaglevGraphBuilder::VisitLdaTheHole()`)
- src/objects/module.cc, module 관련 코드에서 TheHole여부 체크 루틴이 다수 있음. module을 통해 TheHole leak의 가능성을 고민해봐도 좋을 듯
- scope_info(SFI, SharedFunctionInfo)에도 에도 TheHole이 들어갈 수 있는 듯
- class의 super class 등을 나타낼 때 TheHole이 들어갈 수 있는 듯(최상위 클래스의 경우)
- LookupSlot? Context::Lookup? LoadLookupSlot 을 살펴보자
- HashTable의 Lookup 결과가 TheHole 일 수 있음
- wasm

별개로
- set_the_hole, is_the_hole 과 같이 the_hole 으로도 검색을 해 보아야 할 듯
- src/objects/objects.cc, PropertyCell 관련, 30632와 연관하여 필요할 경우 보자



## "TheHole" Keyward Search

**include/v8-function-callback.h**
```cpp
template <typename T>
Local<Value> ReturnValue<T>::Get() const {
  using I = internal::Internals;
  if (*value_ == *I::GetRoot(GetIsolate(), I::kTheHoleValueRootIndex))
    return Local<Value>(*Undefined(GetIsolate()));
  return Local<Value>::New(GetIsolate(), reinterpret_cast<Value*>(value_));
}
```

위 부분이 TheHole 인 값을 읽으려고 하면 undefined가 획득되도록 한 부분인듯? 테스트해보자.

맞긴 맞는듯 한데, libv8을 가져다 쓰는(즉, embedding하는) 경우를 위한 것인듯. d8 콘솔에서는 트리거되지 않음. 

cs 에서 보니 embedding하면서 chromium에서 Get()을 호출하는 경우가 꽤 된다. 이러한 관점으로, TheHole 유출 가능성을 확대해서 chromium 프로젝트까지 훑어 볼 필요도 있을 듯.

Internals::kTheHoleValueRootIndex 가 직접 쓰이는 곳은 위 코드가 유일한 듯.

---

AST에서 TheHole을 나타내기 위해 Literal::kTheHole 을 정의하여 사용함. Literal의 종류는 kSmi, kHeapNumber, kBigInt, kString, kBoolean, kUndefined, kNull, kTheHole. 

파싱 후 AST 구축 중에 배열 hole 처리 관련 구문만 있는 듯...

**src/ast/ast.cc**
```cpp
void ArrayLiteralBoilerplateBuilder::InitDepthAndFlags() {
    ...
        switch (literal->type()) {
          case Literal::kTheHole:
            is_holey = true;
            // The hole is allowed in holey double arrays (and holey Smi
            // arrays), so ignore it as far as is_all_number is concerned.
            break;
    ...
```

TheHole 여부 판단해서 배열의 is_holey 여부 판단함.

```
everyyy@baddell:/work/v8/220317_master/v8$ ./out.gn/x64.release/d8
V8 version 10.1.0 (candidate)
d8> a = [,,]
Literal::kTheHole!
Literal::kTheHole!
[, ]
d8> a = [,1]
Literal::kTheHole!
[, 1]
d8> 
```

---

```cpp
src/baseline/baseline-compiler.cc:
   676  
   677: void BaselineCompiler::VisitLdaTheHole() {
   678:   __ LoadRoot(kInterpreterAccumulatorRegister, RootIndex::kTheHoleValue);
   679  }
```

LdaTheHole 을 따로 더 봐야할까?

---

**src/builtins/accessors.cc**
```cpp
Handle<JSObject> GetFrameArguments(Isolate* isolate,
                                   JavaScriptFrameIterator* it,
                                   int function_index) {
    ...
  for (int i = 0; i < length; i++) {
    Object value = frame->GetParameter(i);
    if (value.IsTheHole(isolate)) {
      // Generators currently use holes as dummy arguments when resuming.  We
      // must not leak those.
      DCHECK(IsResumableFunction(function->shared().kind()));
      value = ReadOnlyRoots(isolate).undefined_value();
    }
    array->set(i, value);
  }
  arguments->set_elements(*array);

  // Return the freshly allocated arguments object.
  return arguments;
}
```

arguments를 설정해주는 부분으로 보이며, TheHole argument일 경우 undefined로 바꿔주는 부분인 듯.

그냥 해서는 위 코드가 잘 트리거가 안됨. 주석을 참고하여 generator 같은 것들을 고려해보아야 할지도...

레퍼런스들을 훑어봐도 어디서부터 호출되는 코드인지 감이 안온다. 호출 안되는 코드인가?

---

```cpp
src/builtins/array-lastindexof.tq
LoadWithHoleCheck<FixedArray>(implicit context: Context)(
    elements: FixedArrayBase, index: Smi): JSAny
    labels IfHole {
  const elements: FixedArray = UnsafeCast<FixedArray>(elements);
  const element: Object = elements.objects[index];
  if (element == TheHole) goto IfHole;
  return UnsafeCast<JSAny>(element);
}

LoadWithHoleCheck<FixedDoubleArray>(implicit context: Context)(
    elements: FixedArrayBase, index: Smi): JSAny
    labels IfHole {
  const elements: FixedDoubleArray = UnsafeCast<FixedDoubleArray>(elements);
  const element: float64 = elements.floats[index].Value() otherwise IfHole;
  return AllocateHeapNumberWithValue(element);
}

macro FastArrayLastIndexOf<Elements : type extends FixedArrayBase>(
    context: Context, array: JSArray, from: Smi, searchElement: JSAny): Smi {
  const elements: FixedArrayBase = array.elements;
  let k: Smi = from;

  // Bug(898785): Due to side-effects in the evaluation of `fromIndex`
  // the {from} can be out-of-bounds here, so we need to clamp {k} to
  // the {elements} length. We might be reading holes / hole NaNs still
  // due to that, but those will be ignored below.
  if (k >= elements.length) {
    k = elements.length - 1;
  }

  while (k >= 0) {
    try {
      const element: JSAny = LoadWithHoleCheck<Elements>(elements, k)
          otherwise Hole;

      const same: Boolean = StrictEqual(searchElement, element);
      if (same == True) {
        dcheck(Is<FastJSArray>(array));
        return k;
      }
    } label Hole {}  // Do nothing for holes.

    --k;
  }

  dcheck(Is<FastJSArray>(array));
  return -1;
}
```

lastIndexOf 구현체를 보면 TheHole을 검증하는 구문이 있다. 이처럼, builtin 함수들 중에서 엘리먼트 접근하는 경우들에 대해 TheHole을 제대로 검증하는지 훑어볼 필요가 있을 듯.

단순한 경로의 접근들은 아마 이미 다 처리가 되어있을 듯하고... 생각치 못한 경우들(side-effect 고려 부족이라든지 최신 문법들-generator 등등...?)을 포함해서 고려해 보아야 할 듯.

---

```js
src/builtins/array.tq
macro LoadElementOrUndefined(implicit context: Context)(
    a: FixedArray, i: Smi): JSAny {
  const e = UnsafeCast<(JSAny | TheHole)>(a.objects[i]);
  return ReplaceTheHoleWithUndefined(e);
}

macro LoadElementOrUndefined(a: FixedDoubleArray, i: Smi): NumberOrUndefined {
  const f: float64 = a.floats[i].Value() otherwise return Undefined;
  return AllocateHeapNumberWithValue(f);
}
```

```js
src/builtins/base.tq
macro ReplaceTheHoleWithUndefined(o: JSAny|TheHole): JSAny {
  typeswitch (o) {
    case (TheHole): {
      return Undefined;
    }
    case (a: JSAny): {
      return a;
    }
  }
}
```

```js
src/objects/js-array.tq
  macro LoadElementOrUndefined(implicit context: Context)(k: Smi): JSAny {
    try {
      return this.LoadElementNoHole(k) otherwise FoundHole;
    } label FoundHole {
      return Undefined;
    }
  }
```

위 코드가 언제 쓰이는 것인지 알아보자.

ReplaceTheHoleWithUndefined 는 LoadElementOrUndefined 에서만 쓰임.

Array.prototype.shift 에서는 js-array.tq 의 LoadElementOrUndefined 를 사용. Array.prototype.find, Array.prototype.findIndex, Array.prototype.findLast, Array.prototype.findLastIndex 다 마찬가지인 듯.

array.tq 의 것은 collections.tq, object-fromentries.tq 에서 array::LoadElementOrUndefined 형태로 쓰고 있는 듯.

```
d8> let myMap = new Map([  [1, 'one'],  [2, 'two'],  [3, 'three']])         
LoadElementOrUndefined(FixedArray), hello!
LoadElementOrUndefined(FixedArray), hello!
ReplaceTheHoleWithUndefined!
ReplaceTheHoleWithUndefined!
...

d8> const entries = new Map([  ['foo', 'bar'],  ['baz', 42]]);
LoadElementOrUndefined(FixedArray), hello!
LoadElementOrUndefined(FixedArray), hello!
ReplaceTheHoleWithUndefined!
ReplaceTheHoleWithUndefined!
...
d8> const obj = Object.fromEntries(entries);
LoadElementOrUndefined(FixedArray), hello!
LoadElementOrUndefined(FixedArray), hello!
ReplaceTheHoleWithUndefined!
ReplaceTheHoleWithUndefined!
...
```

collection의 constructor에서 쓰고 있으며 이는 Map(Set도 될 듯)의 생성자에 iterable을 인자로 줄 경우 트리거 됨 + Object.fromEntries 에서도 트리거 됨 

js-array.tq 의 LoadElementOrUndefined 는 struct FastJSArrayWitness 내에 구현되어 있음. FastJSArrayWitness가 어디서 쓰이는지 알아야 코드가 트리거되는 패스를 찾을 수 있음.

---

```cpp
src/builtins/builtins-array-gen.cc
TF_BUILTIN(ArrayPrototypePop, CodeStubAssembler) {  auto argc = UncheckedParameter<Int32T>(Descriptor::kJSActualArgumentsCount);
  auto context = Parameter<Context>(Descriptor::kContext);
  CSA_DCHECK(this, IsUndefined(Parameter<Object>(Descriptor::kJSNewTarget)));

  CodeStubArguments args(this, argc);
  TNode<Object> receiver = args.GetReceiver();

  Label runtime(this, Label::kDeferred);
  Label fast(this);

  // Only pop in this stub if
  // 1) the array has fast elements
  // 2) the length is writable,
  // 3) the elements backing store isn't copy-on-write,
  // 4) we aren't supposed to shrink the backing store.

  // 1) Check that the array has fast elements.
  Print("TF_BUILTIN(ArrayPrototypePop)");
  Print("receiver: ", receiver);
  Print("");
  Print("context: ", context);
  BranchIfFastJSArray(receiver, context, &fast, &runtime);

    ...

    BIND(&fast_elements);
    {
      Print("Fast Elements !!!");
      TNode<FixedArray> elements_known_fixed_array = CAST(elements);
      TNode<Object> value =
          LoadFixedArrayElement(elements_known_fixed_array, new_length);
      StoreFixedArrayElement(elements_known_fixed_array, new_length,
                             TheHoleConstant());
      GotoIf(TaggedEqual(value, TheHoleConstant()), &return_undefined);
      args.PopAndReturn(value);
    }
}
```

위처럼 receiver 와 context도 출력이 됨 

```
receiver: : DebugPrint: 0x2b480004a469: [JSArray]
 - map: 0x2b4800203a79 <Map(PACKED_SMI_ELEMENTS)> [FastProperties]
 - prototype: 0x2b48001cc321 <JSArray[0]>
 ...

context: : DebugPrint: 0x2b48001c3681: [NativeContext] in OldSpace
 - map: 0x2b4800202179 <Map>
 - type: NATIVE_CONTEXT_TYPE
 - scope_info: 0x2b48000036b9 <ScopeInfo SCRIPT_SCOPE>
 - previous: 0
 - native_context: 0x2b48001c3681 <NativeContext[270]>
 - extension: 0x2b48001d0e15 <JSGlobalObject>
 - length: 270
 - elements:
           0: 0x2b48000036b9 <ScopeInfo SCRIPT_SCOPE>
           1: 0
           2: 0x2b48001d0e15 <JSGlobalObject>
           3: 0x2b48001c3671 <JSGlobalProxy>
           4: 0x2b4800049de1 <Other heap object (EMBEDDER_DATA_ARRAY_TYPE)>
           5: 0x2b48000023f1 <undefined>
           6: 0x2b48001cc8a1 <JSFunction next (sfi = 0x2b480015bbe5)>
           7: 0x2b48001cc8bd <JSFunction next (sfi = 0x2b480015bc09)>
    ...

         264: 0x2b48000023f1 <undefined>
         265: 0x2b48000021f1 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
         266: 0x2b48000035a9 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
     267-269: 0x2b48000023f1 <undefined>
 - microtask_queue: 0x556ff97047e0
0x2b4800202179: [Map]
 - type: NATIVE_CONTEXT_TYPE
 - instance size: variable
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - stable_map
 - native context: 0x2b48001c3681 <NativeContext[270]>
 - prototype_validity cell: 0
 - instance descriptors (own) #0: 0x2b48000021fd <Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)>
 - prototype: 0x2b4800002271 <null>
 - dependent code: 0x2b48000021f1 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```

위 코드에서 TheHoleConstant()를 store하는 것은 첫 번째 pop 에서는 트리거되지 않음. 

```
d8> a = [1, 2, 3, 4, 5, 6, 7];
d8> a.pop(); <---- 트리거 안됨
d8> a.pop(); <---- 여기서 트리거 됨
```

array literal로 생성한 의 elements는 FixedCOWArrayMap 이며 따라서 Array.prototype.pop TF_BUILTIN 함수 내에서 runtime 패스로 빠짐. 여기서 elements를 위한 fixed array가 다시 생성되며 이 때는 FixedArray의 Map을 가짐(tools/v8heapconstants.py 참고). 두 번째 pop 수행시 fast_elements 패스로 수행되며 이때 `StoreFixedArrayElement(elements_known_fixed_array, new_length, TheHoleConstant());` 가 수행됨. 즉, pop 한 element의 위치에 TheHole을 채워넣음.

참고사항: JSArray의 length는 pop 수행 시마다 줄어들지만 elements(FixedArray)의 length는 줄어들지 않음.

---

```cpp
src/builtins/builtins-constructor-gen.cc
TF_BUILTIN(FastNewClosure, ConstructorBuiltinsAssembler) {
        ...
  {
    // Set function prototype if necessary.
    Label done(this), init_prototype(this);
    Branch(IsFunctionWithPrototypeSlotMap(function_map), &init_prototype,
           &done);

    BIND(&init_prototype);
    StoreObjectFieldRoot(result, JSFunction::kPrototypeOrInitialMapOffset,
                         RootIndex::kTheHoleValue);
    Goto(&done);
    BIND(&done);
  }
        ...
```

prototype에 TheHole이 쓰여지는 경우가 있는 듯? 이건 나중에 꼭 자세히 파 보자.

```cpp
src/compiler/js-create-lowering.cc
Reduction JSCreateLowering::ReduceJSCreateClosure(Node* node) {
            ...
  if (function_map.has_prototype_slot()) {
    a.Store(AccessBuilder::ForJSFunctionPrototypeOrInitialMap(),
            jsgraph()->TheHoleConstant());
    STATIC_ASSERT(JSFunction::kSizeWithPrototype == 8 * kTaggedSize);
  }
            ...
```

compiler 에도 비슷한 루틴 존재. Implicit receiver를 나타낼 때 TheHole을 쓰는 듯

---

```cpp
src/builtins/builtins-internal-gen.cc
  void DictionarySpecificDelete(TNode<JSReceiver> receiver,
                                TNode<NameDictionary> properties,
                                TNode<IntPtrT> key_index,
                                TNode<Context> context) {
    // Overwrite the entry itself (see NameDictionary::SetEntry).
    TNode<Oddball> filler = TheHoleConstant();
    DCHECK(RootsTable::IsImmortalImmovable(RootIndex::kTheHoleValue));
    StoreFixedArrayElement(properties, key_index, filler, SKIP_WRITE_BARRIER);
    StoreValueByKeyIndex<NameDictionary>(properties, key_index, filler,
                                         SKIP_WRITE_BARRIER);
    StoreDetailsByKeyIndex<NameDictionary>(properties, key_index,
                                           SmiConstant(0));
        ...
```

Dictionary의 경우에도 Delete 시 TheHole로 나타내는 듯

---

```cpp
src/builtins/builtins-internal-gen.cc
TF_BUILTIN(AdaptorWithBuiltinExitFrame, CodeStubAssembler) {
            ...
  TailCallStub(CEntry1ArgvOnStackDescriptor{},  // descriptor
               code, context,       // standard arguments for TailCallStub
               argc, c_function,    // register arguments
               TheHoleConstant(),   // additional stack argument 1 (padding)
               SmiFromInt32(argc),  // additional stack argument 2
               target,              // additional stack argument 3
               new_target);         // additional stack argument 4
}
```

AdaptorWithBuiltinExitFrame 는 low level에서만 사용되는 함수인 듯 하다. 한 번 훑어 볼 필요는 있을 듯. Adaptor?

---

```cpp
src/builtins/builtins-iterator-gen.cc
TNode<FixedArray> IteratorBuiltinsAssembler::StringListFromIterable(
    TNode<Context> context, TNode<Object> iterable) {
            ...
      // 2. Return ? IteratorClose(iteratorRecord, error).
      BIND(&if_exception);
      TNode<HeapObject> message = GetPendingMessage();
      SetPendingMessage(TheHoleConstant());
      IteratorCloseOnException(context, iterator_record);
      CallRuntime(Runtime::kReThrowWithMessage, context, var_exception.value(),
                  message);
      Unreachable();
    }
            ...
```

https://bugs.chromium.org/p/v8/issues/detail?id=12439 때 패치된 코드 중 한 곳임.
exception 발생 시 message가 TheHole이 되도록 할 수가 있었나 봄... 패치를 놓친 곳이 있을 지 어떨지 확인해 볼 필요가 있을 듯. PendingMessage 관련.

---

빌트인 함수 구현(tq, CSA, TF_BUILTIN, ...)에 배열(FixedArray), 문자열 등등에서 TheHole이 두루 쓰이는 듯. 단순히 쓰이는 것 보다 그걸 가져오는 방법에 대한 조사가 필요... 아마 이쪽은 거의 가능성이 없을 것으로 예상. 

src/codegen/code-stub-assembler.cc 에도 다수 있음. IsTheHole 과 같은 비교구문 외에도 `FillFixedArrayWithValue(kind, elements, IntPtrConstant(0), capacity, RootIndex::kTheHoleValue);` 와 같이 FixedArray를 채울 때에도 사용됨(AllocateJsArray, ExtractFixedArray 등). 

AllocateSwissNameDictionaryWithCapacity in code-stub-assembler.cc. SwissNameDictionary는 객체의 property를 dictionary 형태로 나타낼 때 쓰는 듯 하다. 

---

```cpp
src/debug/debug-interface.cc
MaybeLocal<v8::Value> EphemeronTable::Get(v8::Isolate* isolate,
                                          v8::Local<v8::Value> key) {
  i::Isolate* internal_isolate = reinterpret_cast<i::Isolate*>(isolate);
  auto self = i::Handle<i::EphemeronHashTable>::cast(Utils::OpenHandle(this));
  i::Handle<i::Object> internal_key = Utils::OpenHandle(*key);
  DCHECK(internal_key->IsJSReceiver());

  i::Handle<i::Object> value(self->Lookup(internal_key), internal_isolate);

  if (value->IsTheHole()) return {};
  return Utils::ToLocal(value);
}
```

위 코드 보고 든 생각. Map 객체(혹은 WeakMap 등등...)에서 value만 TheHole일 수 있을까? (즉, get 을 시도했을 때 value가 TheHole이 되도록)

isolate가 TheHole 인건 무슨 의미지? debug, diagnostics 쪽에 이런 코드가 쫌 보이는데...

---

```cpp
src/objects/arguments.tq
struct ParameterValueIterator {
  macro Next(): Object labels NoMore() {
    if (this.mapped_count != 0) {
      this.mapped_count--;
      return TheHole;
    }
    if (this.current == this.arguments.length) goto NoMore;
    return this.arguments[this.current++];
  }
  mapped_count: intptr;
  const arguments: Arguments;
  current: intptr;
}

src/objects/fixed-array.tq
macro ExtractFixedArray(
    source: FixedArray, first: intptr, count: intptr,
    capacity: intptr): FixedArray {
  // TODO(turbofan): This should be optimized to use memcpy for initialization.
  return NewFixedArray(
      capacity,
      IteratorSequence<Object>(
          (&source.objects).Iterator(first, first + count),
          ConstantIterator(TheHole)));
}
```

torque에서 NewFixedArray는 length와 iterator를 입력으로 받고 iterator가 주는 값들로 FixedArray의 elements 값들을 초기화함. 위 처럼 TheHole로 초기화 하는 경우가 있음. FixedArray의 element에 TheHole 값이 저장되는 것은 매우 자연스러운 일임.

---

```cpp
src/objects/elements.cc
void CopyPackedSmiToDoubleElements(FixedArrayBase from_base,
                                   uint32_t from_start, FixedArrayBase to_base,
                                   uint32_t to_start, int packed_size,
                                   int raw_copy_size) {
                ...
  for (uint32_t from_end = from_start + static_cast<uint32_t>(packed_size);
       from_start < from_end; from_start++, to_start++) {
    Object smi = from.get(from_start);
    DCHECK(!smi.IsTheHole());
    to.set(to_start, Smi::ToInt(smi));
  }
}
```

packed 이므로 `DCHECK(!smi.IsTheHole());` 검증을 수행하는 것 같은데... TheHole 이면 무슨 문제가 있나? [Issue 7598: AllocateJSArray may expose the hole](https://bugs.chromium.org/p/v8/issues/detail?id=7598&q=hole&can=1) 을 참고해보면 어떨런지? TheHole에 대해 `Smi::ToInt()`를 수행하는 것이 문제가 될런지. TODO

---

```cpp
src/objects/elements.cc
void CopyDictionaryToObjectElements(Isolate* isolate, FixedArrayBase from_base,
                                    uint32_t from_start, FixedArrayBase to_base,
                                    ElementsKind to_kind, uint32_t to_start,
                                    int raw_copy_size) {
                ...
  WriteBarrierMode write_barrier_mode = GetWriteBarrierMode(to, to_kind, no_gc);
  for (int i = 0; i < copy_size; i++) {
    InternalIndex entry = from.FindEntry(isolate, i + from_start);
    if (entry.is_found()) {
      Object value = from.ValueAt(entry);
      DCHECK(!value.IsTheHole(isolate));
      to.set(i + to_start, value, write_barrier_mode);
    } else {
      to.set_the_hole(isolate, i + to_start);
    }
  }
}
```

TheHole 여부를 확인하여(`entry.is_found()`) set을 구분하고 있는데 set 의 경우는 write barrier가 필요하고 set_the_hole은 NoWriteBarrierSet를 통해 수행되는 차이가 있으므로 이를 구분하기 위한 것으로 보인다.

---

```cpp
src/objects/shared-function-info-inl.h
void SharedFunctionInfo::set_outer_scope_info(HeapObject value,
                                              WriteBarrierMode mode) {
  DCHECK(!is_compiled());
  DCHECK(raw_outer_scope_info_or_feedback_metadata().IsTheHole());
  DCHECK(value.IsScopeInfo() || value.IsTheHole());
  set_raw_outer_scope_info_or_feedback_metadata(value, mode);
}

src/objects/shared-function-info.cc
void SharedFunctionInfo::DiscardCompiledMetadata(
            ...
    DCHECK(outer_scope_info().IsScopeInfo() || outer_scope_info().IsTheHole());
            ...
```

SFI(SharedFunctionInfo), scope_info에도 TheHole이 저장될 수 있는 듯. 이것이 leak이 될 수가 있나...? 없을거같은데. 아마 top-level 일 때 TheHole 일 것 같은데.

---

```cpp
src/runtime/runtime-classes.cc
MaybeHandle<Object> DefineClass(Isolate* isolate,
                                Handle<ClassBoilerplate> class_boilerplate,
                                Handle<Object> super_class,
                                Handle<JSFunction> constructor,
                                RuntimeArguments& args) {
  Handle<Object> prototype_parent;
  Handle<HeapObject> constructor_parent;

  if (super_class->IsTheHole(isolate)) {
    prototype_parent = isolate->initial_object_prototype();
  } else {
                    ...
```

class의 super class 등을 나타낼 때에 TheHoleㅣ 쓰이는 듯?

---

```cpp
src/runtime/runtime-scopes.cc
MaybeHandle<Object> LoadLookupSlot(Isolate* isolate, Handle<String> name,
                                   ShouldThrow should_throw,
                                   Handle<Object>* receiver_return = nullptr) {
                    ...
  if (index != Context::kNotFound) {
    DCHECK(holder->IsContext());
    // If the "property" we were looking for is a local variable, the
    // receiver is the global object; see ECMA-262, 3rd., 10.1.6 and 10.2.3.
    Handle<Object> receiver = isolate->factory()->undefined_value();
    Handle<Object> value = handle(Context::cast(*holder).get(index), isolate);
    // Check for uninitialized bindings.
    if (flag == kNeedsInitialization && value->IsTheHole(isolate)) {
      THROW_NEW_ERROR(isolate,
                      NewReferenceError(MessageTemplate::kNotDefined, name),
                      Object);
    }
    DCHECK(!value->IsTheHole(isolate));
    if (receiver_return) *receiver_return = receiver;
    return value;
  }
                    ...
```

flag != kNeedsInitialization 이면서 value가 TheHole인 경우를 찾아보면 어떨까? LoadLookupSlot은 Runtime 함수에서 호출하며 해당 Runtime 함수들은 interpreter, compiler, src/ic/accessor-assembler.cc 등에서 호출됨(Runtime::kLoadLookupSlot[...] 으로 검색)

추측: 여기서 Lookup이라 함은 property를 찾는 것을 의미하는 것이 아닐까. Initialization이 필요한 경우(kNeedsInitialization)에만 TheHole 값을 갖나본데. kNeedsInitialization을 피하면서 TheHole을 갖게 하면 TheHole이 leak 될 것 같기도? (물론 현재는 분석하기 전이므로 소설임) TODO

StoreLookupSlot 도 참고 

---

```cpp
test/cctest/test-dictionary.cc
template <class HashMap>
static void TestHashMapDoesNotCauseGC(Handle<HashMap> table) {
                    ...
  // Calling Lookup() should not cause GC ever.
  CHECK(table->Lookup(key).IsTheHole(isolate));
                    ...
```

위의 Lookup은 ObjectHashTableBase의 Lookup임([ref](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/objects.cc;drc=42e75824670baadf21ece40f71b946500af1cbce;l=6335)). 이처럼 hash table로부터 lookup 수행 결과에 대해서 TheHole 여부를 체크해야 하는데, 체크하지 않는 곳이 있을런지? TODO

---


## "the_hole" Keyward Search

---

```cpp
src/api/api-arguments.cc:
  27    // It cannot escape into js as it's removed in Call below.
  28:   HeapObject the_hole = ReadOnlyRoots(isolate).the_hole_value();
  29:   slot_at(T::kReturnValueDefaultValueIndex).store(the_hole);
  30:   slot_at(T::kReturnValueIndex).store(the_hole);
  31    DCHECK((*slot_at(T::kHolderIndex)).IsHeapObject());

  45    // It cannot escape into js as it's remove in Call below.
  46:   HeapObject the_hole = ReadOnlyRoots(isolate).the_hole_value();
  47:   slot_at(T::kReturnValueDefaultValueIndex).store(the_hole);
  48:   slot_at(T::kReturnValueIndex).store(the_hole);
  49    DCHECK((*slot_at(T::kHolderIndex)).IsHeapObject());
```

PropertyCallbackArguments, FunctionCallbackArguments. api 쪽. TODO

---





ㅁㄴㅇㄹ

---

## pending_exception, scheduled_exception 

```cpp
src/execution/isolate-inl.h

Object Isolate::pending_exception() {
  CHECK(has_pending_exception());       // <--- changed from DCHECK to CHECK
  DCHECK(!thread_local_top()->pending_exception_.IsException(this));
  return thread_local_top()->pending_exception_;
}

void Isolate::clear_pending_exception() {
  DCHECK(!thread_local_top()->pending_exception_.IsException(this));
  thread_local_top()->pending_exception_ = ReadOnlyRoots(this).the_hole_value();
}

Object Isolate::scheduled_exception() {
  DCHECK(has_scheduled_exception());    // <--- 얘는 아직 DCHECK 임 
  DCHECK(!thread_local_top()->scheduled_exception_.IsException(this));
  return thread_local_top()->scheduled_exception_;
}

void Isolate::clear_scheduled_exception() {
  DCHECK(!thread_local_top()->scheduled_exception_.IsException(this));
  set_scheduled_exception(ReadOnlyRoots(this).the_hole_value());
}
```

38003과 관련된 것. pending_exception이 CHECK로 패치되었다. scheduled_exception은 아직 DCHECK 인데... 얘도 결국 나중에 pending_exception 자리를 거친다면 결국 CHECK에서 걸린다는 건데... 

```cpp
src/execution/isolate.h
  // Promote a scheduled exception to pending. Asserts has_scheduled_exception.
  Object PromoteScheduledException();
```

위는 이러한 생각을 뒷받침해주는 코드 일부(주석)

### exception 처리 과정 분석

38003 이슈 페이지에서 언급되어있듯이 builtins-x64.cc(혹은 builtins-arm64.cc 등)에서 exception sentinel 값(RootIndex::kException)과 비교하여 익셉션 발생 여부 확인. 이후 `ExternalReference find_handler = ExternalReference::Create(Runtime::kUnwindAndFindExceptionHandler);`  구문을 통해 런타임 함수 UnwindAndFindExceptionHandler를 호출. 

```cpp
src/runtime/runtime-internal.cc
RUNTIME_FUNCTION(Runtime_UnwindAndFindExceptionHandler) {
  SealHandleScope shs(isolate);
  DCHECK_EQ(0, args.length());
  return isolate->UnwindAndFindHandler();
}

src/execution/isolate.cc
Object Isolate::UnwindAndFindHandler() {
					...
  Object exception = pending_exception();
  					...
    clear_pending_exception();
    return exception;
  };
					...
```

결국 pending_exception()을 통해 익셉션을 획득함.

### PromoteScheduledException()

```cpp
src/execution/isolate.cc
Object Isolate::PromoteScheduledException() {
  Object thrown = scheduled_exception();
  clear_scheduled_exception();
  // Re-throw the exception to avoid getting repeated error reporting.
  return ReThrow(thrown);
}

Object Isolate::ReThrow(Object exception) {
  DCHECK(!has_pending_exception());

  // Set the exception being re-thrown.
  set_pending_exception(exception);
  return ReadOnlyRoots(heap()).exception();
}
```

ReThrow 에서 set_pending_exception 후에 pending_exception()을 리턴하는 것이 아닌 `ReadOnlyRoots(heap()).exception();`를 리턴하는데, ~~그러면 pending_exception() 내에서 설정된 CHECK 를 안거치는 것 아닌가?~~ 결국 machinery 코드에서 UnwindAndFindHandler를 통해 pending_exception()이 호출되어 결국 걸리는 듯...

```cpp
src/execution/isolate.h

#define RETURN_FAILURE_IF_SCHEDULED_EXCEPTION(isolate) \
  do {                                                 \
    Isolate* __isolate__ = (isolate);                  \
    DCHECK(!__isolate__->has_pending_exception());     \
    if (__isolate__->has_scheduled_exception()) {      \
      return __isolate__->PromoteScheduledException(); \
    }                                                  \
  } while (false)

// Macros for MaybeHandle.

#define RETURN_VALUE_IF_SCHEDULED_EXCEPTION(isolate, value) \
  do {                                                      \
    Isolate* __isolate__ = (isolate);                       \
    DCHECK(!__isolate__->has_pending_exception());          \
    if (__isolate__->has_scheduled_exception()) {           \
      __isolate__->PromoteScheduledException();             \
      return value;                                         \
    }                                                       \
  } while (false)

#define RETURN_EXCEPTION_IF_SCHEDULED_EXCEPTION(isolate, T) \
  RETURN_VALUE_IF_SCHEDULED_EXCEPTION(isolate, MaybeHandle<T>())

#define ASSIGN_RETURN_ON_SCHEDULED_EXCEPTION_VALUE(isolate, dst, call, value) \
  do {                                                                        \
    Isolate* __isolate__ = (isolate);                                         \
    if (!(call).ToLocal(&dst)) {                                              \
      DCHECK(__isolate__->has_scheduled_exception());                         \
      __isolate__->PromoteScheduledException();                               \
      return value;                                                           \
    }                                                                         \
  } while (false)

#define RETURN_ON_SCHEDULED_EXCEPTION_VALUE(isolate, call, value) \
  do {                                                            \
    Isolate* __isolate__ = (isolate);                             \
    if ((call).IsNothing()) {                                     \
      DCHECK(__isolate__->has_scheduled_exception());             \
      __isolate__->PromoteScheduledException();                   \
      return value;                                               \
    }                                                             \
  } while (false)
```

~~위처럼 RETURN_어쩌구... 매크로에서도 has_scheduled_exception() 으로 이미 검증 수행 후 PromoteScheduledException()을 수행함. ~~

ASSIGN_RETURN_ON_SCHEDULED_EXCEPTION_VALUE, RETURN_ON_SCHEDULED_EXCEPTION_VALUE 의 경우는 DCHECK로만 수행함. 더 살펴볼 필요 있음. TODO

```cpp
src/objects/source-text-module.cc
bool SourceTextModule::PrepareInstantiate(
    Isolate* isolate, Handle<SourceTextModule> module,
    v8::Local<v8::Context> context, v8::Module::ResolveModuleCallback callback,
    Module::DeprecatedResolveCallback callback_without_import_assertions) {
                ...
      if (!callback(context, v8::Utils::ToLocal(specifier),
                    v8::Utils::FixedArrayToLocal(import_assertions),
                    v8::Utils::ToLocal(Handle<Module>::cast(module)))
               .ToLocal(&api_requested_module)) {
        isolate->PromoteScheduledException();
        return false;
      }
    } else {
      if (!callback_without_import_assertions(
               context, v8::Utils::ToLocal(specifier),
               v8::Utils::ToLocal(Handle<Module>::cast(module)))
               .ToLocal(&api_requested_module)) {
        isolate->PromoteScheduledException();
        return false;
      }
                ...
```

PrepareInstantiate 함수 역할이 뭔지, callback이 뭐하는 앤지, callback_without_import_assertions이 뭐하는 앤지 모르겠다. 당장은 이해하기 어려움... TODO

```cpp
src/objects/synthetic-module.cc
MaybeHandle<Object> SyntheticModule::Evaluate(Isolate* isolate,
                                              Handle<SyntheticModule> module) {
                ...
  if (!evaluation_steps(
           Utils::ToLocal(Handle<Context>::cast(isolate->native_context())),
           Utils::ToLocal(Handle<Module>::cast(module)))
           .ToLocal(&result)) {
    isolate->PromoteScheduledException();
    Module::RecordErrorUsingPendingException(isolate, module);
    return MaybeHandle<Object>();
  }
                ...
```

이 코드도 역할을 잘 모르겠음. 당장은 이해하기 어려움... TODO

```cpp
RUNTIME_FUNCTION(Runtime_PromoteScheduledException) {
  SealHandleScope shs(isolate);
  DCHECK_EQ(0, args.length());
  return isolate->PromoteScheduledException();
}
```

runtime 함수도 있네... 어떻게 써먹지? ㅋㅋ

PromoteScheduledException 얘는 has_scheduled_exception() 안붙어있는 애들은 위에 언급한 애들이 전부인 듯. 다 훑어보자. 


### scheduled_exception()

scheduled_exception() 호출 전에 has_scheduled_exception() 으로 검증하지 않아야 할 듯.

찾아봤는데 PromoteScheduledException 관련 외에는 모두 has_scheduled_exception()을 거치는 듯.

### [ASSIGN_]RETURN_ON_SCHEDULED_EXCEPTION_VALUE

키워드 검색 시 몇 개 안나옴, TODO


### etc

```cpp
void Isolate::clear_pending_message() {
  set_pending_message(ReadOnlyRoots(this).the_hole_value());
}
```

얘도 참고하자. (얘는 IteratorCloseOnException 관련하여)

```cpp
src/execution/isolate.cc
void Isolate::RestorePendingMessageFromTryCatch(v8::TryCatch* handler) {
  DCHECK(handler == try_catch_handler());
  DCHECK(handler->HasCaught());
  DCHECK(handler->rethrow_);
  DCHECK(handler->capture_message_);
  Object message(reinterpret_cast<Address>(handler->message_obj_));
  DCHECK(message.IsJSMessageObject() || message.IsTheHole(this));
  set_pending_message(message);
}
```

이런 코드들을 보면 애초에 message는 TheHole이어도 된다고 가정하고 코딩한 듯 하다. 그 얘기는, 결국 TheHole값이 정상적으로 필터링 될 것임을 의미하는 것인가...

---


## v8:12439

```cpp
src/builtins/builtins-temporal-gen.cc
TNode<FixedArray>
TemporalBuiltinsAssembler::TemporalInstantFixedArrayFromIterable(
    TNode<Context> context, TNode<Object> iterable) {
            ...
      BIND(&if_exception);
      IteratorCloseOnException(context, iterator_record);
      CallRuntime(Runtime::kReThrow, context, var_exception.value());
      Unreachable();
            ...
```

IteratorCloseOnException + Runtime::kReThrow 조합인데? builtins-temporal-gen.cc 는 bug:v8:12439 때 없던 파일임. 이거 많이 수상한데...

https://chromium.googlesource.com/v8/v8/+blame/8b663818fc311217c2cdaaab935f020578bfb7a8/src/builtins/builtins-temporal-gen.cc

2022-01-06 에 추가됨(v8:12439는 2021-11-27, commit은 2021-12-06)

이건 지금 바로 봐야겠다.

### 참고 - test 코드

```cpp
test/cctest/heap/test-heap.cc
static void CheckLeak(const v8::FunctionCallbackInfo<v8::Value>& args) {
  Isolate* isolate = CcTest::i_isolate();
  Object message(
      *reinterpret_cast<Address*>(isolate->pending_message_address()));
  CHECK(message.IsTheHole(isolate));
}
```

pending message가 TheHole 인지를 확인하는 체크 코드...?

### IteratorCloseOnException

patchset 1 을 보면 src/builtins/iterator.tq 내 IteratorCloseOnException 에서 ~~Pending Message 관련 처리가 이미 추가되었음... 따라서 이미 패치가 된 것으로 봐야 할 수도. :(~~

patchset 1 에서 추가되었다가 피드백을 받아 변경되었음. 꼼꼼히 보자.

힌트를 얻기 위해서 commit message 등을 보고 있는데... 

1. (from v8:12439)
> We currently don't do that. So when Isolate::pending_message is being cleared or overwritten by an unrelated exception inside of JS code called from IteratorCloseOnException, it can result in the original exception being combined with an unrelated message or TheHole.


2. (from patchset 1)
> [builtins] IteratorCloseOnException needs to preserve the pending message

pending message를 백업해두지 않으면 IterateCloseOnException 내에서 임의 js 수행 시 pending exception + pending message 가 overwritten 될 수 있으므로 이를 고려하여 pending message를 보존해두어야 한다는 의미.

IterateCloseOnException 내에서 임의 js 실행, 다른 Exception 발생(+ 그 exception이 message를 TheHole로 설정하는 경우를 찾아야 함?)

message가 TheHole일 경우 유저에게 TheHole이 leak 되는지 확인 필요(즉, 정말 보안 이슈가 있는지, 아니면 단순 메시지 출력의 오류일 뿐인지 확인 필요)

`SetPendingMessage(TheHole);`를 이미 쓰고 있는 것을 보아... TheHole이 leak되는 경우는 없는 것 같기도 하다... 쩝.

참고: GetAndResetPendingMessage도 v8:12439 에서 추가됨 

```cpp
src/codegen/code-stub-assembler.cc
TNode<HeapObject> CodeStubAssembler::GetPendingMessage() {
  TNode<ExternalReference> pending_message = ExternalConstant(
      ExternalReference::address_of_pending_message(isolate()));
  return UncheckedCast<HeapObject>(LoadFullTagged(pending_message));
}
void CodeStubAssembler::SetPendingMessage(TNode<HeapObject> message) {
  CSA_DCHECK(this, Word32Or(IsTheHole(message),
                            InstanceTypeEqual(LoadInstanceType(message),
                                              JS_MESSAGE_OBJECT_TYPE)));
  TNode<ExternalReference> pending_message = ExternalConstant(
      ExternalReference::address_of_pending_message(isolate()));
  StoreFullTaggedNoWriteBarrier(pending_message, message);
}
```

위와 같이 GetPendingMessage, SetPendingMessage 가 v8:12439에서 추가됨.


### exception message, pending message

익셉션의 메시지는 어떤 흐름을 거쳐서 js에서 접근하게 되는거지?

```cpp
src/execution/isolate.cc
Object Isolate::ThrowInternal(Object raw_exception, MessageLocation* location) {
                    ...
  // Generate the message if required.
  if (requires_message && !rethrowing_message) {
    MessageLocation computed_location;
    // If no location was specified we try to use a computed one instead.
    if (location == nullptr && ComputeLocation(&computed_location)) {
      location = &computed_location;
    }
    if (bootstrapper()->IsActive()) {
                    ...
    } else {
      Handle<Object> message_obj = CreateMessageOrAbort(exception, location);
      set_pending_message(*message_obj);
    }
  }

  // Set the exception being thrown.
  set_pending_exception(*exception);
  return ReadOnlyRoots(heap()).exception();
}
```

```js
try {
  //throw new Error("");
  //throw new Error();
  throw new Error("qwerasdf");
} catch (e) {
  %DebugPrint(e);
  %SystemBreak();
  console.log("e: ");
  console.log(e);
  console.log("e.stack: ");
  console.log(e.stack);
  console.log("e.message: ");
  console.log(e.message);
  %DebugPrint(e);
  %SystemBreak();
  console.log(e.message);
}

````

아래와 같은 js 코드를 이용하여 Throw를 통해 익셉션을 발생시키면 위의 ThrowInternal 코드가 수행됨. 이해가 잘 안되는 점은, CreateMessageOrAbort 를 통해 JSMessageObject 객체를 생성하고 이를 set_pending_message(...)를 통해 설정하는 것이 catch를 통해 잡은 e의 message 프로퍼티와 무관해보인다는 점임. 실제로, CreateMessageOrAbort 및 set_pending_message 구문을 변경하거나 주석처리해도 message 프로퍼티에 저장되는 값은 변화가 없음. 

지금 드는 생각 하나. message 프로퍼티는 Error 클래스의 생성자에서 발생하는 것 같다. 그렇다면, pending_message의 역할은 대체 뭐지?

#### throw 를 통한 익셉션 처리 과정 및 분석

```
DEBUG:: v8::internal::Object v8::internal::Isolate::ThrowInternal(v8::internal::Object, v8::internal::MessageLocation *)
--- raw_exception ---
0x17fb0004a631: [JS_ERROR_TYPE]
 - map: 0x17fb00207bc9 <Map(HOLEY_ELEMENTS)> [FastProperties]
 - prototype: 0x17fb001c5cd1 <Object map = 0x17fb002028d1>
 - elements: 0x17fb00002269 <FixedArray[0]> [HOLEY_ELEMENTS]
 - properties: 0x17fb00002269 <FixedArray[0]>
 - All own properties (excluding elements): {
    0x17fb000057c1: [String] in ReadOnlySpace: #stack: 0x17fb0014432d <AccessorInfo> (const accessor descriptor), location: descriptor
    0x17fb0000501d: [String] in ReadOnlySpace: #message: 0x17fb001d3591 <String[8]: #qwerasdf> (const data field 0), location: in-object
    0x17fb00005bf1 <Symbol: (error_stack_symbol)>: 0x17fb0004a671 <FixedArray[1]> (const data field 1), location: in-object
 }
```

ThrowInternal의 첫 번째 인자 raw_exception 이 js 코드에서 throw로 던진 객체임. 문자열을 던졌을 경우 문자열 객체가 raw_exception에 들어가며 `new Error("qwerasdf")`를 던졌을 경우 JS_ERROR_TYPE 객체가 들어감. 위 로그에서는 JS_ERROR_TYPE 객체의 message 프로퍼티에 문자열 "qwerasdf"가 들어있는 것을 확인할 수 있음. 즉, 던질 객체가 생성될 때 이미 message 프로퍼티에 문자열이 저장됨. 

```cpp
src/builtins/accessors.cc
void Accessors::ArrayLengthSetter(
    v8::Local<v8::Name> name, v8::Local<v8::Value> val,
    const v8::PropertyCallbackInfo<v8::Boolean>& info) {   
                    ...
  Handle<Object> length_obj = Utils::OpenHandle(*val);
                    ...
  uint32_t length = 0;
  if (!JSArray::AnythingToArrayLength(isolate, length_obj, &length)) {
    isolate->OptionalRescheduleException(false);
    return;
  }
                    ...

src/objects/objects.cc
bool JSArray::AnythingToArrayLength(Isolate* isolate,
                                    Handle<Object> length_object,
                                    uint32_t* output) {
                    ...
  if (uint32_v->Number() != number_v->Number()) {
    Handle<Object> exception =
        isolate->factory()->NewRangeError(MessageTemplate::kInvalidArrayLength);
    isolate->Throw(*exception);
    return false;
  }
                    ...
```

Throw를 수행하는 한 예임. `a = [1, 2, 3]; a.length = "asdf";` 와 같이 수행하면 `"Invalid array length"` 문자열이 포함된 에러 객체가 생성되는 과정임.

던질 객체의 message 프로퍼티에 저장되는 메시지와 pending_message는 다른 개념인가보다. pending_message에 저장되는 JSMessageObject는 콘솔에 출력되는 그 문자열을 의미하는 듯...

```cpp
      Handle<Object> message_obj = CreateMessageOrAbort(exception, location);
      set_pending_message(*message_obj);
```
ThrowInternal의 raw_exception은 `Handle<Object> exception(raw_exception, this);` 핸들 형태의 exception으로 감싸진 후 CreateMessageOrAbort 함수로 전달되고 그 결과가 set_pending_message에 전달됨.

```cpp
src/execution/isolate.cc
Handle<JSMessageObject> Isolate::CreateMessageOrAbort(
    Handle<Object> exception, MessageLocation* location) {
  Handle<JSMessageObject> message_obj = CreateMessage(exception, location);

Handle<JSMessageObject> Isolate::CreateMessage(Handle<Object> exception,
                                               MessageLocation* location) {
                    ...
  return MessageHandler::MakeMessageObject(
      this, MessageTemplate::kUncaughtException, location, exception,
      stack_trace_object);
}

src/execution/messages.cc
Handle<JSMessageObject> MessageHandler::MakeMessageObject(
    Isolate* isolate, MessageTemplate message, const MessageLocation* location,
    Handle<Object> argument, Handle<FixedArray> stack_frames) {
                    ...
  Handle<JSMessageObject> message_obj = factory->NewJSMessageObject(
      message, argument, start, end, shared_info, bytecode_offset,
      script_handle, stack_frames_handle);

  return message_obj;
}

src/heap/factory.cc
Handle<JSMessageObject> Factory::NewJSMessageObject(
    MessageTemplate message, Handle<Object> argument, int start_position,
    int end_position, Handle<SharedFunctionInfo> shared_info,
    int bytecode_offset, Handle<Script> script, Handle<Object> stack_frames) {
  Handle<Map> map = message_object_map();
  JSMessageObject message_obj =
      JSMessageObject::cast(New(map, AllocationType::kYoung));
  DisallowGarbageCollection no_gc;
                ...
  message_obj.set_argument(*argument, SKIP_WRITE_BARRIER);
                ...
  return handle(message_obj, isolate());
}
```

CreateMessageOrAbort에 이어 CreateMessage 호출, MakeMessageObject 호출, NewJSMessageObject 호출, exception이 `message_obj.set_argument(*argument, SKIP_WRITE_BARRIER);`를 통해 argument로 설정됨.

set_pending_message에 저장된 것은 pending_message() 를 통해 쓰이는데 `void BaselineCompiler::VisitSetPendingMessage()` 랑 `TNode<HeapObject> CodeStubAssembler::GetPendingMessage()`도 봐야하나... 머리가 복잡하다. GetPendingMessage()는 봐야 할 듯... 쓰이는 곳이 많지는 않네. CSA 런타임에서 쓰이는 듯. 

#### GetPendingMessage()

생각해보니 GetPendingMessage()는 v8:12439 에서 생긴 함수임. GetPendingMessage()가 쓰이는 곳들 중에 유의미하게 살펴볼 곳은 없는 듯... 

#### pending_message()

void BaselineCompiler::VisitSetPendingMessage() 신경 써야 할까? 

```cpp
src/execution/isolate.cc
void Isolate::ReportPendingMessages() {
					...
  Object message_obj = pending_message();
  clear_pending_message();
  					...
  if (!message_obj.IsTheHole(this) && should_report_exception) {
  					...
  }
}
```

TheHole 여부 체크함.

---

```cpp
src/execution/isolate.cc
bool Isolate::PropagatePendingExceptionToExternalTryCatch(
    ExceptionHandlerType top_handler) {
  Object exception = pending_exception();
  					...
  if (!is_catchable_by_javascript(exception)) {
    SetTerminationOnExternalTryCatch();
  } else {
  					...
    // Propagate to the external try-catch only if we got an actual message.
    if (!has_pending_message()) return true;
    handler->message_obj_ = reinterpret_cast<void*>(pending_message().ptr());
  }
  return true;
}
```

has_pending_message()를 통해 TheHole 체크함.

```cpp
src/objects/objects.cc
static void MoveMessageToPromise(Isolate* isolate, Handle<JSPromise> promise) {
  if (!isolate->has_pending_message()) return;

  Handle<Object> message = handle(isolate->pending_message(), isolate);
  Handle<Symbol> key = isolate->factory()->promise_debug_message_symbol();
  Object::SetProperty(isolate, promise, key, message, StoreOrigin::kMaybeKeyed,
                      Just(ShouldThrow::kThrowOnError))
      .Assert();

  // The message object for a rejected promise was only stored for this purpose.
  // Clear it, otherwise we might leak memory.
  isolate->clear_pending_message();
}
```

has_pending_message()를 통해 TheHole 체크함.

이런...

### Temporal 대상 트리거 코드 구현

버그는 버그니까... 라는 생각으로 트리거 코드 한 번 구현해보자. 자신감도 쌓을 겸.

1. Temporal 에서 해당 코드 트리거되도록 poc 작성
2. IteratorCloseOnException 트리거 확인

```cpp
src/flags/flag-definitions.h
// Features that are still work in progress (behind individual flags).
#define HARMONY_INPROGRESS_BASE(V)                                             \
  V(harmony_weak_refs_with_cleanup_some,                                       \
    "harmony weak references with FinalizationRegistry.prototype.cleanupSome") \
  V(harmony_import_assertions, "harmony import assertions")                    \
  V(harmony_temporal, "Temporal")                                              \
  V(harmony_shadow_realm, "harmony ShadowRealm")                               \
  V(harmony_struct, "harmony structs and shared structs")
```

Temporal은 아직 미완성된 feature라 --harmony-temoral 플래그가 필요함. ~~(근데 크롬 개발자도구에선 되던데? 뭐지...)~~ [tc39 페이지](https://tc39.es/proposal-temporal/docs/timezone.html#getPossibleInstantsFor)에서만 사용 가능했던 것. Polyfill 인 듯.

```cpp
src/init/bootstrapper.cc
  // The TemporalInsantFixedArrayFromIterable functions is created but not
  // exposed, as it is used internally by GetPossibleInstantsFor.
  {
    Handle<JSFunction> func = SimpleCreateFunction(
        isolate_,
        factory()->InternalizeUtf8String(
            "TemporalInstantFixedArrayFromIterable"),
        Builtin::kTemporalInstantFixedArrayFromIterable, 1, false);
    native_context()->set_temporal_instant_fixed_array_from_iterable(*func);
  }
```

GetPossibleInstantsFor 에서 내부적으로만 사용한다 함.

```
d8> tz.getPossibleInstantsFor("asdf");


#
# Fatal error in , line 0
# unimplemented code
#
#
#
#FailureMessage Object: 0x7ffc881e5230
==== C stack trace ===============================

    ./x64.release/d8(+0x100eb33) [0x556348401b33]
    ./x64.release/d8(+0x100e3eb) [0x5563484013eb]
    ./x64.release/d8(+0x1004805) [0x5563483f7805]
    ./x64.release/d8(+0x45bf09) [0x55634784ef09]
    [0x5562cff0d9f8]
Trace/breakpoint trap (core dumped)
everyyy@baddell:/work/v8/220317_master/v8/out.gn$ 
```

왓더...

```cpp
src/builtins/builtins-temporal.cc
#define TO_BE_IMPLEMENTED(id)   \
  BUILTIN_NO_RCS(id) {          \
    HandleScope scope(isolate); \
    UNIMPLEMENTED();            \
  }
  					...
/* Temporal #sec-temporal.timezone.prototype.getpossibleinstantsfor */
TO_BE_IMPLEMENTED(TemporalTimeZonePrototypeGetPossibleInstantsFor)
```

아직 미구현 상태... 나중에 구현 풀리면 그때 해보자. TODO









