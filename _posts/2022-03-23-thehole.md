---
layout: post
title: TheHole
date: 2022-03-23 14:05
summary: Let's try to leak TheHole
meta_robots: noindex, nofollow
---

## Environments

```
everyyy@baddell:/work/v8/220317_master/v8$ git rev-parse HEAD
e62f556862624103ea1da5b9dcef9b216832033b
everyyy@baddell:/work/v8/220317_master/v8$ git describe --contains
10.1.124~1
everyyy@baddell:/work/v8/220317_master/v8$
```

## TheHole

38003에서 힌트를 얻어서 시작.

**src/builtins/builtins-collections-gen.cc** 를 보면 TheHoleConstant() 함수를 통해 TheHole 값을 사용하고 있음. 해당 함수는 **src/codegen/code-stub-assembler.cc** 에서 매크로를 통해 생성된 것.

**src/codegen/code-stub-assembler.cc**
```cpp
#define HEAP_CONSTANT_ACCESSOR(rootIndexName, rootAccessorName, name)        \
  TNode<std::remove_pointer<std::remove_reference<decltype(                  \
      std::declval<ReadOnlyRoots>().rootAccessorName())>::type>::type>       \
      CodeStubAssembler::name##Constant() {                                  \
    return UncheckedCast<std::remove_pointer<std::remove_reference<decltype( \
        std::declval<ReadOnlyRoots>().rootAccessorName())>::type>::type>(    \
        LoadRoot(RootIndex::k##rootIndexName));                              \
  }
HEAP_IMMUTABLE_IMMOVABLE_OBJECT_LIST(HEAP_CONSTANT_ACCESSOR)
#undef HEAP_CONSTANT_ACCESSOR
```

**src/codegen/code-stub-assembler.h**
```cpp
#define HEAP_IMMUTABLE_IMMOVABLE_OBJECT_LIST(V)                              \
...
  V(TheHoleValue, the_hole_value, TheHole)                                   \
...

...
#define HEAP_IMMOVABLE_OBJECT_LIST(V)   \
  HEAP_MUTABLE_IMMOVABLE_OBJECT_LIST(V) \
  HEAP_IMMUTABLE_IMMOVABLE_OBJECT_LIST(V)
```

"TheHole" 과 "the_hole_value" 를 키워드로 소스코드 리파지토리 대상 전체 키워드 검색해서 훑어보기로 하자.

아니면... --background-index=true 옵션 줘서 인덱싱을 다 한듯한데... reference를 찾아서 볼까.

일단 전체적인 감을 잡기 위해 키워드 검색부터 훑어보자.

```cpp
src/heap/setup-heap-internal.cc

bool Heap::CreateInitialMaps() {
                    ...
  set_the_hole_value(Oddball::cast(obj));
  Oddball::cast(obj).set_kind(Oddball::kTheHole);
                    ...

void Heap::CreateInitialObjects() {
                    ...
  // Initialize the_hole_value.
  Oddball::Initialize(isolate(), factory->the_hole_value(), "hole",
                      factory->hole_nan_value(), "undefined",
                      Oddball::kTheHole);
                    ...

```

TheHole 이 초기화되는 코드인 듯.



### TheHole이 쓰이는 곳들

배열의 빈 element를 나타낼 때
- 이후 이를 접근하는 다양한 코드 패스들에 대해 TheHole을 검증하는 루틴이 존재함
- TheHole을 검증하지 않고 접근하는 코드 패스가 있는지 찾아 볼 필요가 있음, 이는 (당연하게도) TheHole 키워드 검색으로 발견되지 않으므로 좀 더 수고스러운 코드 분석이 필요할 것으로 생각됨.
- map, set, weakmap 등 collection 객체에서 삭제된 키(및 값)를 TheHole로 나타냄(src/builtins/builtins-collections-gen.cc)
- src/builtins/builtins-constructor-gen.cc, prototype(아니면 initial map?)에 TheHole이 쓰여지는 경우가 있는 듯
- src/builtins/builtins-internal-gen.cc, Dictionary의 경우에도 Delete 시(아마도 property?) TheHole을 씀
- src/builtins/builtins-internal-gen.cc, TF_BUILTIN(AdaptorWithBuiltinExitFrame), 의미 분석 필요 
- ** exception의 pending message가 clear되어 TheHole이 유출될 가능성이 있었던 듯? (src/builtins/builtins-iterator-gen.cc 참고), https://bugs.chromium.org/p/v8/issues/detail?id=12439 요 링크 참고해보자
- Promise(tq 파일들) 관련 코드들에서도 좀 보임...
- src/builtins/.../builtins-....cc 에 구현된 로우 레벨 코드에서도 사용되는 경우가 여럿 있으며(RootIndex::kTheHoleValue) 각각 사용되는 경우마다 분석이 필요할 듯. 이는 나중에 분석을 하긴 해야 할 듯. (어려워보임)
- compiler 에서는 Type::Hole(), OddballType::kHole, jsgraph->TheHoleConstant() 형태 등으로 사용됨. compiler 에서의 TheHole 사용은 나중에 따로 모아서 정리해보자
- ** scheduled_exception 관련 
- 인터프리터에서 BytecodeArrayBuilder& BytecodeArrayBuilder::LoadTheHole() 와 같은 경우에도 쓰임. Interpreter에서 쓰이는 경우도 언젠간 봐야 할지도... 인터프리터 자체에 대한 이해가 필요해서 많이 어려울 듯. 
- maglev(`void MaglevGraphBuilder::VisitLdaTheHole()`)

별개로
- set_the_hole, is_the_hole 과 같이 the_hole 으로도 검색을 해 보아야 할 듯




## "TheHole" Keyward Search

**include/v8-function-callback.h**
```cpp
template <typename T>
Local<Value> ReturnValue<T>::Get() const {
  using I = internal::Internals;
  if (*value_ == *I::GetRoot(GetIsolate(), I::kTheHoleValueRootIndex))
    return Local<Value>(*Undefined(GetIsolate()));
  return Local<Value>::New(GetIsolate(), reinterpret_cast<Value*>(value_));
}
```

위 부분이 TheHole 인 값을 읽으려고 하면 undefined가 획득되도록 한 부분인듯? 테스트해보자.

맞긴 맞는듯 한데, libv8을 가져다 쓰는(즉, embedding하는) 경우를 위한 것인듯. d8 콘솔에서는 트리거되지 않음. 

cs 에서 보니 embedding하면서 chromium에서 Get()을 호출하는 경우가 꽤 된다. 이러한 관점으로, TheHole 유출 가능성을 확대해서 chromium 프로젝트까지 훑어 볼 필요도 있을 듯.

Internals::kTheHoleValueRootIndex 가 직접 쓰이는 곳은 위 코드가 유일한 듯.

---

AST에서 TheHole을 나타내기 위해 Literal::kTheHole 을 정의하여 사용함. Literal의 종류는 kSmi, kHeapNumber, kBigInt, kString, kBoolean, kUndefined, kNull, kTheHole. 

파싱 후 AST 구축 중에 배열 hole 처리 관련 구문만 있는 듯...

**src/ast/ast.cc**
```cpp
void ArrayLiteralBoilerplateBuilder::InitDepthAndFlags() {
    ...
        switch (literal->type()) {
          case Literal::kTheHole:
            is_holey = true;
            // The hole is allowed in holey double arrays (and holey Smi
            // arrays), so ignore it as far as is_all_number is concerned.
            break;
    ...
```

TheHole 여부 판단해서 배열의 is_holey 여부 판단함.

```
everyyy@baddell:/work/v8/220317_master/v8$ ./out.gn/x64.release/d8
V8 version 10.1.0 (candidate)
d8> a = [,,]
Literal::kTheHole!
Literal::kTheHole!
[, ]
d8> a = [,1]
Literal::kTheHole!
[, 1]
d8> 
```

---

```cpp
src/baseline/baseline-compiler.cc:
   676  
   677: void BaselineCompiler::VisitLdaTheHole() {
   678:   __ LoadRoot(kInterpreterAccumulatorRegister, RootIndex::kTheHoleValue);
   679  }
```

LdaTheHole 을 따로 더 봐야할까?

---

**src/builtins/accessors.cc**
```cpp
Handle<JSObject> GetFrameArguments(Isolate* isolate,
                                   JavaScriptFrameIterator* it,
                                   int function_index) {
    ...
  for (int i = 0; i < length; i++) {
    Object value = frame->GetParameter(i);
    if (value.IsTheHole(isolate)) {
      // Generators currently use holes as dummy arguments when resuming.  We
      // must not leak those.
      DCHECK(IsResumableFunction(function->shared().kind()));
      value = ReadOnlyRoots(isolate).undefined_value();
    }
    array->set(i, value);
  }
  arguments->set_elements(*array);

  // Return the freshly allocated arguments object.
  return arguments;
}
```

arguments를 설정해주는 부분으로 보이며, TheHole argument일 경우 undefined로 바꿔주는 부분인 듯.

그냥 해서는 위 코드가 잘 트리거가 안됨. 주석을 참고하여 generator 같은 것들을 고려해보아야 할지도...

레퍼런스들을 훑어봐도 어디서부터 호출되는 코드인지 감이 안온다. 호출 안되는 코드인가?

---

```cpp
src/builtins/array-lastindexof.tq
LoadWithHoleCheck<FixedArray>(implicit context: Context)(
    elements: FixedArrayBase, index: Smi): JSAny
    labels IfHole {
  const elements: FixedArray = UnsafeCast<FixedArray>(elements);
  const element: Object = elements.objects[index];
  if (element == TheHole) goto IfHole;
  return UnsafeCast<JSAny>(element);
}

LoadWithHoleCheck<FixedDoubleArray>(implicit context: Context)(
    elements: FixedArrayBase, index: Smi): JSAny
    labels IfHole {
  const elements: FixedDoubleArray = UnsafeCast<FixedDoubleArray>(elements);
  const element: float64 = elements.floats[index].Value() otherwise IfHole;
  return AllocateHeapNumberWithValue(element);
}

macro FastArrayLastIndexOf<Elements : type extends FixedArrayBase>(
    context: Context, array: JSArray, from: Smi, searchElement: JSAny): Smi {
  const elements: FixedArrayBase = array.elements;
  let k: Smi = from;

  // Bug(898785): Due to side-effects in the evaluation of `fromIndex`
  // the {from} can be out-of-bounds here, so we need to clamp {k} to
  // the {elements} length. We might be reading holes / hole NaNs still
  // due to that, but those will be ignored below.
  if (k >= elements.length) {
    k = elements.length - 1;
  }

  while (k >= 0) {
    try {
      const element: JSAny = LoadWithHoleCheck<Elements>(elements, k)
          otherwise Hole;

      const same: Boolean = StrictEqual(searchElement, element);
      if (same == True) {
        dcheck(Is<FastJSArray>(array));
        return k;
      }
    } label Hole {}  // Do nothing for holes.

    --k;
  }

  dcheck(Is<FastJSArray>(array));
  return -1;
}
```

lastIndexOf 구현체를 보면 TheHole을 검증하는 구문이 있다. 이처럼, builtin 함수들 중에서 엘리먼트 접근하는 경우들에 대해 TheHole을 제대로 검증하는지 훑어볼 필요가 있을 듯.

단순한 경로의 접근들은 아마 이미 다 처리가 되어있을 듯하고... 생각치 못한 경우들(side-effect 고려 부족이라든지 최신 문법들-generator 등등...?)을 포함해서 고려해 보아야 할 듯.

---

```js
src/builtins/array.tq
macro LoadElementOrUndefined(implicit context: Context)(
    a: FixedArray, i: Smi): JSAny {
  const e = UnsafeCast<(JSAny | TheHole)>(a.objects[i]);
  return ReplaceTheHoleWithUndefined(e);
}

macro LoadElementOrUndefined(a: FixedDoubleArray, i: Smi): NumberOrUndefined {
  const f: float64 = a.floats[i].Value() otherwise return Undefined;
  return AllocateHeapNumberWithValue(f);
}
```

```js
src/builtins/base.tq
macro ReplaceTheHoleWithUndefined(o: JSAny|TheHole): JSAny {
  typeswitch (o) {
    case (TheHole): {
      return Undefined;
    }
    case (a: JSAny): {
      return a;
    }
  }
}
```

```js
src/objects/js-array.tq
  macro LoadElementOrUndefined(implicit context: Context)(k: Smi): JSAny {
    try {
      return this.LoadElementNoHole(k) otherwise FoundHole;
    } label FoundHole {
      return Undefined;
    }
  }
```

위 코드가 언제 쓰이는 것인지 알아보자.

ReplaceTheHoleWithUndefined 는 LoadElementOrUndefined 에서만 쓰임.

Array.prototype.shift 에서는 js-array.tq 의 LoadElementOrUndefined 를 사용. Array.prototype.find, Array.prototype.findIndex, Array.prototype.findLast, Array.prototype.findLastIndex 다 마찬가지인 듯.

array.tq 의 것은 collections.tq, object-fromentries.tq 에서 array::LoadElementOrUndefined 형태로 쓰고 있는 듯.

```
d8> let myMap = new Map([  [1, 'one'],  [2, 'two'],  [3, 'three']])         
LoadElementOrUndefined(FixedArray), hello!
LoadElementOrUndefined(FixedArray), hello!
ReplaceTheHoleWithUndefined!
ReplaceTheHoleWithUndefined!
...

d8> const entries = new Map([  ['foo', 'bar'],  ['baz', 42]]);
LoadElementOrUndefined(FixedArray), hello!
LoadElementOrUndefined(FixedArray), hello!
ReplaceTheHoleWithUndefined!
ReplaceTheHoleWithUndefined!
...
d8> const obj = Object.fromEntries(entries);
LoadElementOrUndefined(FixedArray), hello!
LoadElementOrUndefined(FixedArray), hello!
ReplaceTheHoleWithUndefined!
ReplaceTheHoleWithUndefined!
...
```

collection의 constructor에서 쓰고 있으며 이는 Map(Set도 될 듯)의 생성자에 iterable을 인자로 줄 경우 트리거 됨 + Object.fromEntries 에서도 트리거 됨 

---

```cpp
src/builtins/builtins-array-gen.cc
TF_BUILTIN(ArrayPrototypePop, CodeStubAssembler) {  auto argc = UncheckedParameter<Int32T>(Descriptor::kJSActualArgumentsCount);
  auto context = Parameter<Context>(Descriptor::kContext);
  CSA_DCHECK(this, IsUndefined(Parameter<Object>(Descriptor::kJSNewTarget)));

  CodeStubArguments args(this, argc);
  TNode<Object> receiver = args.GetReceiver();

  Label runtime(this, Label::kDeferred);
  Label fast(this);

  // Only pop in this stub if
  // 1) the array has fast elements
  // 2) the length is writable,
  // 3) the elements backing store isn't copy-on-write,
  // 4) we aren't supposed to shrink the backing store.

  // 1) Check that the array has fast elements.
  Print("TF_BUILTIN(ArrayPrototypePop)");
  Print("receiver: ", receiver);
  Print("");
  Print("context: ", context);
  BranchIfFastJSArray(receiver, context, &fast, &runtime);

    ...

    BIND(&fast_elements);
    {
      Print("Fast Elements !!!");
      TNode<FixedArray> elements_known_fixed_array = CAST(elements);
      TNode<Object> value =
          LoadFixedArrayElement(elements_known_fixed_array, new_length);
      StoreFixedArrayElement(elements_known_fixed_array, new_length,
                             TheHoleConstant());
      GotoIf(TaggedEqual(value, TheHoleConstant()), &return_undefined);
      args.PopAndReturn(value);
    }
}
```

위처럼 receiver 와 context도 출력이 됨 

```
receiver: : DebugPrint: 0x2b480004a469: [JSArray]
 - map: 0x2b4800203a79 <Map(PACKED_SMI_ELEMENTS)> [FastProperties]
 - prototype: 0x2b48001cc321 <JSArray[0]>
 ...

context: : DebugPrint: 0x2b48001c3681: [NativeContext] in OldSpace
 - map: 0x2b4800202179 <Map>
 - type: NATIVE_CONTEXT_TYPE
 - scope_info: 0x2b48000036b9 <ScopeInfo SCRIPT_SCOPE>
 - previous: 0
 - native_context: 0x2b48001c3681 <NativeContext[270]>
 - extension: 0x2b48001d0e15 <JSGlobalObject>
 - length: 270
 - elements:
           0: 0x2b48000036b9 <ScopeInfo SCRIPT_SCOPE>
           1: 0
           2: 0x2b48001d0e15 <JSGlobalObject>
           3: 0x2b48001c3671 <JSGlobalProxy>
           4: 0x2b4800049de1 <Other heap object (EMBEDDER_DATA_ARRAY_TYPE)>
           5: 0x2b48000023f1 <undefined>
           6: 0x2b48001cc8a1 <JSFunction next (sfi = 0x2b480015bbe5)>
           7: 0x2b48001cc8bd <JSFunction next (sfi = 0x2b480015bc09)>
    ...

         264: 0x2b48000023f1 <undefined>
         265: 0x2b48000021f1 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
         266: 0x2b48000035a9 <Other heap object (WEAK_FIXED_ARRAY_TYPE)>
     267-269: 0x2b48000023f1 <undefined>
 - microtask_queue: 0x556ff97047e0
0x2b4800202179: [Map]
 - type: NATIVE_CONTEXT_TYPE
 - instance size: variable
 - elements kind: HOLEY_ELEMENTS
 - unused property fields: 0
 - enum length: invalid
 - stable_map
 - native context: 0x2b48001c3681 <NativeContext[270]>
 - prototype_validity cell: 0
 - instance descriptors (own) #0: 0x2b48000021fd <Other heap object (STRONG_DESCRIPTOR_ARRAY_TYPE)>
 - prototype: 0x2b4800002271 <null>
 - dependent code: 0x2b48000021f1 <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0
```

위 코드에서 TheHoleConstant()를 store하는 것은 첫 번째 pop 에서는 트리거되지 않음. 

```
d8> a = [1, 2, 3, 4, 5, 6, 7];
d8> a.pop(); <---- 트리거 안됨
d8> a.pop(); <---- 여기서 트리거 됨
```

array literal로 생성한 의 elements는 FixedCOWArrayMap 이며 따라서 Array.prototype.pop TF_BUILTIN 함수 내에서 runtime 패스로 빠짐. 여기서 elements를 위한 fixed array가 다시 생성되며 이 때는 FixedArray의 Map을 가짐(tools/v8heapconstants.py 참고). 두 번째 pop 수행시 fast_elements 패스로 수행되며 이때 `StoreFixedArrayElement(elements_known_fixed_array, new_length, TheHoleConstant());` 가 수행됨. 즉, pop 한 element의 위치에 TheHole을 채워넣음.

참고사항: JSArray의 length는 pop 수행 시마다 줄어들지만 elements(FixedArray)의 length는 줄어들지 않음.

---

```cpp
src/builtins/builtins-constructor-gen.cc
TF_BUILTIN(FastNewClosure, ConstructorBuiltinsAssembler) {
        ...
  {
    // Set function prototype if necessary.
    Label done(this), init_prototype(this);
    Branch(IsFunctionWithPrototypeSlotMap(function_map), &init_prototype,
           &done);

    BIND(&init_prototype);
    StoreObjectFieldRoot(result, JSFunction::kPrototypeOrInitialMapOffset,
                         RootIndex::kTheHoleValue);
    Goto(&done);
    BIND(&done);
  }
        ...
```

prototype에 TheHole이 쓰여지는 경우가 있는 듯? 이건 나중에 꼭 자세히 파 보자.

```cpp
src/compiler/js-create-lowering.cc
Reduction JSCreateLowering::ReduceJSCreateClosure(Node* node) {
            ...
  if (function_map.has_prototype_slot()) {
    a.Store(AccessBuilder::ForJSFunctionPrototypeOrInitialMap(),
            jsgraph()->TheHoleConstant());
    STATIC_ASSERT(JSFunction::kSizeWithPrototype == 8 * kTaggedSize);
  }
            ...
```

compiler 에도 비슷한 루틴 존재. Implicit receiver를 나타낼 때 TheHole을 쓰는 듯

---

```cpp
src/builtins/builtins-internal-gen.cc
  void DictionarySpecificDelete(TNode<JSReceiver> receiver,
                                TNode<NameDictionary> properties,
                                TNode<IntPtrT> key_index,
                                TNode<Context> context) {
    // Overwrite the entry itself (see NameDictionary::SetEntry).
    TNode<Oddball> filler = TheHoleConstant();
    DCHECK(RootsTable::IsImmortalImmovable(RootIndex::kTheHoleValue));
    StoreFixedArrayElement(properties, key_index, filler, SKIP_WRITE_BARRIER);
    StoreValueByKeyIndex<NameDictionary>(properties, key_index, filler,
                                         SKIP_WRITE_BARRIER);
    StoreDetailsByKeyIndex<NameDictionary>(properties, key_index,
                                           SmiConstant(0));
        ...
```

Dictionary의 경우에도 Delete 시 TheHole로 나타내는 듯

---

```cpp
src/builtins/builtins-internal-gen.cc
TF_BUILTIN(AdaptorWithBuiltinExitFrame, CodeStubAssembler) {
            ...
  TailCallStub(CEntry1ArgvOnStackDescriptor{},  // descriptor
               code, context,       // standard arguments for TailCallStub
               argc, c_function,    // register arguments
               TheHoleConstant(),   // additional stack argument 1 (padding)
               SmiFromInt32(argc),  // additional stack argument 2
               target,              // additional stack argument 3
               new_target);         // additional stack argument 4
}
```

AdaptorWithBuiltinExitFrame 는 low level에서만 사용되는 함수인 듯 하다. 한 번 훑어 볼 필요는 있을 듯. Adaptor?

---

```cpp
src/builtins/builtins-iterator-gen.cc
TNode<FixedArray> IteratorBuiltinsAssembler::StringListFromIterable(
    TNode<Context> context, TNode<Object> iterable) {
            ...
      // 2. Return ? IteratorClose(iteratorRecord, error).
      BIND(&if_exception);
      TNode<HeapObject> message = GetPendingMessage();
      SetPendingMessage(TheHoleConstant());
      IteratorCloseOnException(context, iterator_record);
      CallRuntime(Runtime::kReThrowWithMessage, context, var_exception.value(),
                  message);
      Unreachable();
    }
            ...
```

https://bugs.chromium.org/p/v8/issues/detail?id=12439 때 패치된 코드 중 한 곳임.
exception 발생 시 message가 TheHole이 되도록 할 수가 있었나 봄... 패치를 놓친 곳이 있을 지 어떨지 확인해 볼 필요가 있을 듯. PendingMessage 관련.

---

빌트인 함수 구현(tq, CSA, TF_BUILTIN, ...)에 배열(FixedArray), 문자열 등등에서 TheHole이 두루 쓰이는 듯. 단순히 쓰이는 것 보다 그걸 가져오는 방법에 대한 조사가 필요... 아마 이쪽은 거의 가능성이 없을 것으로 예상. 

src/codegen/code-stub-assembler.cc 에도 다수 있음. IsTheHole 과 같은 비교구문 외에도 `FillFixedArrayWithValue(kind, elements, IntPtrConstant(0), capacity, RootIndex::kTheHoleValue);` 와 같이 FixedArray를 채울 때에도 사용됨(AllocateJsArray, ExtractFixedArray 등). 

AllocateSwissNameDictionaryWithCapacity in code-stub-assembler.cc

---

```cpp
src/debug/debug-interface.cc
MaybeLocal<v8::Value> EphemeronTable::Get(v8::Isolate* isolate,
                                          v8::Local<v8::Value> key) {
  i::Isolate* internal_isolate = reinterpret_cast<i::Isolate*>(isolate);
  auto self = i::Handle<i::EphemeronHashTable>::cast(Utils::OpenHandle(this));
  i::Handle<i::Object> internal_key = Utils::OpenHandle(*key);
  DCHECK(internal_key->IsJSReceiver());

  i::Handle<i::Object> value(self->Lookup(internal_key), internal_isolate);

  if (value->IsTheHole()) return {};
  return Utils::ToLocal(value);
}
```

위 코드 보고 든 생각. Map 객체(혹은 WeakMap 등등...)에서 value만 TheHole일 수 있을까? (즉, get 을 시도했을 때 value가 TheHole이 되도록)

isolate가 TheHole 인건 무슨 의미지? debug, diagnostics 쪽에 이런 코드가 쫌 보이는데...

---

```cpp
src/objects/arguments.tq
struct ParameterValueIterator {
  macro Next(): Object labels NoMore() {
    if (this.mapped_count != 0) {
      this.mapped_count--;
      return TheHole;
    }
    if (this.current == this.arguments.length) goto NoMore;
    return this.arguments[this.current++];
  }
  mapped_count: intptr;
  const arguments: Arguments;
  current: intptr;
}

src/objects/fixed-array.tq
macro ExtractFixedArray(
    source: FixedArray, first: intptr, count: intptr,
    capacity: intptr): FixedArray {
  // TODO(turbofan): This should be optimized to use memcpy for initialization.
  return NewFixedArray(
      capacity,
      IteratorSequence<Object>(
          (&source.objects).Iterator(first, first + count),
          ConstantIterator(TheHole)));
}
```

torque에서 NewFixedArray는 length와 iterator를 입력으로 받고 iterator가 주는 값들로 FixedArray의 elements 값들을 초기화함. 위 처럼 TheHole로 초기화 하는 경우가 있음. FixedArray의 element에 TheHole 값이 저장되는 것은 매우 자연스러운 일임.

---

```cpp
src/objects/elements.cc
void CopyPackedSmiToDoubleElements(FixedArrayBase from_base,
                                   uint32_t from_start, FixedArrayBase to_base,
                                   uint32_t to_start, int packed_size,
                                   int raw_copy_size) {
                ...
  for (uint32_t from_end = from_start + static_cast<uint32_t>(packed_size);
       from_start < from_end; from_start++, to_start++) {
    Object smi = from.get(from_start);
    DCHECK(!smi.IsTheHole());
    to.set(to_start, Smi::ToInt(smi));
  }
}
```

packed 이므로 `DCHECK(!smi.IsTheHole());` 검증을 수행하는 것 같은데... TheHole 이면 무슨 문제가 있나? [Issue 7598: AllocateJSArray may expose the hole](https://bugs.chromium.org/p/v8/issues/detail?id=7598&q=hole&can=1) 을 참고해보면 어떨런지? TheHole에 대해 `Smi::ToInt()`를 수행하는 것이 문제가 될런지. TODO

---

```cpp
src/objects/elements.cc
void CopyDictionaryToObjectElements(Isolate* isolate, FixedArrayBase from_base,
                                    uint32_t from_start, FixedArrayBase to_base,
                                    ElementsKind to_kind, uint32_t to_start,
                                    int raw_copy_size) {
                ...
  WriteBarrierMode write_barrier_mode = GetWriteBarrierMode(to, to_kind, no_gc);
  for (int i = 0; i < copy_size; i++) {
    InternalIndex entry = from.FindEntry(isolate, i + from_start);
    if (entry.is_found()) {
      Object value = from.ValueAt(entry);
      DCHECK(!value.IsTheHole(isolate));
      to.set(i + to_start, value, write_barrier_mode);
    } else {
      to.set_the_hole(isolate, i + to_start);
    }
  }
}
```

TheHole 여부를 확인하여(`entry.is_found()`) set을 구분하고 있는데 set 의 경우는 write barrier가 필요하고 set_the_hole은 NoWriteBarrierSet를 통해 수행되는 차이가 있으므로 이를 구분하기 위한 것으로 보인다.

---

ㅁㄴㅇㄹ

---

## pending_exception, scheduled_exception 

```cpp
src/execution/isolate-inl.h

Object Isolate::pending_exception() {
  CHECK(has_pending_exception());       // <--- changed from DCHECK to CHECK
  DCHECK(!thread_local_top()->pending_exception_.IsException(this));
  return thread_local_top()->pending_exception_;
}

void Isolate::clear_pending_exception() {
  DCHECK(!thread_local_top()->pending_exception_.IsException(this));
  thread_local_top()->pending_exception_ = ReadOnlyRoots(this).the_hole_value();
}

Object Isolate::scheduled_exception() {
  DCHECK(has_scheduled_exception());    // <--- 얘는 아직 DCHECK 임 
  DCHECK(!thread_local_top()->scheduled_exception_.IsException(this));
  return thread_local_top()->scheduled_exception_;
}

void Isolate::clear_scheduled_exception() {
  DCHECK(!thread_local_top()->scheduled_exception_.IsException(this));
  set_scheduled_exception(ReadOnlyRoots(this).the_hole_value());
}
```

38003과 관련된 것. pending_exception이 CHECK로 패치되었다. scheduled_exception은 아직 DCHECK 인데... 얘도 결국 나중에 pending_exception 자리를 거친다면 결국 CHECK에서 걸린다는 건데... 

```cpp
src/execution/isolate.h
  // Promote a scheduled exception to pending. Asserts has_scheduled_exception.
  Object PromoteScheduledException();
```

위는 이러한 생각을 뒷받침해주는 코드 일부(주석)

### PromoteScheduledException()

```cpp
src/execution/isolate.cc
Object Isolate::PromoteScheduledException() {
  Object thrown = scheduled_exception();
  clear_scheduled_exception();
  // Re-throw the exception to avoid getting repeated error reporting.
  return ReThrow(thrown);
}

Object Isolate::ReThrow(Object exception) {
  DCHECK(!has_pending_exception());

  // Set the exception being re-thrown.
  set_pending_exception(exception);
  return ReadOnlyRoots(heap()).exception();
}
```

ReThrow 에서 set_pending_exception 후에 pending_exception()을 리턴하는 것이 아닌 `ReadOnlyRoots(heap()).exception();`를 리턴하는데, 그러면 pending_exception() 내에서 설정된 CHECK 를 안거치는 것 아닌가? TODO

```cpp
src/execution/isolate.h

#define RETURN_FAILURE_IF_SCHEDULED_EXCEPTION(isolate) \
  do {                                                 \
    Isolate* __isolate__ = (isolate);                  \
    DCHECK(!__isolate__->has_pending_exception());     \
    if (__isolate__->has_scheduled_exception()) {      \
      return __isolate__->PromoteScheduledException(); \
    }                                                  \
  } while (false)

// Macros for MaybeHandle.

#define RETURN_VALUE_IF_SCHEDULED_EXCEPTION(isolate, value) \
  do {                                                      \
    Isolate* __isolate__ = (isolate);                       \
    DCHECK(!__isolate__->has_pending_exception());          \
    if (__isolate__->has_scheduled_exception()) {           \
      __isolate__->PromoteScheduledException();             \
      return value;                                         \
    }                                                       \
  } while (false)

#define RETURN_EXCEPTION_IF_SCHEDULED_EXCEPTION(isolate, T) \
  RETURN_VALUE_IF_SCHEDULED_EXCEPTION(isolate, MaybeHandle<T>())

#define ASSIGN_RETURN_ON_SCHEDULED_EXCEPTION_VALUE(isolate, dst, call, value) \
  do {                                                                        \
    Isolate* __isolate__ = (isolate);                                         \
    if (!(call).ToLocal(&dst)) {                                              \
      DCHECK(__isolate__->has_scheduled_exception());                         \
      __isolate__->PromoteScheduledException();                               \
      return value;                                                           \
    }                                                                         \
  } while (false)

#define RETURN_ON_SCHEDULED_EXCEPTION_VALUE(isolate, call, value) \
  do {                                                            \
    Isolate* __isolate__ = (isolate);                             \
    if ((call).IsNothing()) {                                     \
      DCHECK(__isolate__->has_scheduled_exception());             \
      __isolate__->PromoteScheduledException();                   \
      return value;                                               \
    }                                                             \
  } while (false)
```

~~위처럼 RETURN_어쩌구... 매크로에서도 has_scheduled_exception() 으로 이미 검증 수행 후 PromoteScheduledException()을 수행함. ~~

ASSIGN_RETURN_ON_SCHEDULED_EXCEPTION_VALUE, RETURN_ON_SCHEDULED_EXCEPTION_VALUE 의 경우는 DCHECK로만 수행함. 더 살펴볼 필요 있음. TODO

```cpp
src/objects/source-text-module.cc
bool SourceTextModule::PrepareInstantiate(
    Isolate* isolate, Handle<SourceTextModule> module,
    v8::Local<v8::Context> context, v8::Module::ResolveModuleCallback callback,
    Module::DeprecatedResolveCallback callback_without_import_assertions) {
                ...
      if (!callback(context, v8::Utils::ToLocal(specifier),
                    v8::Utils::FixedArrayToLocal(import_assertions),
                    v8::Utils::ToLocal(Handle<Module>::cast(module)))
               .ToLocal(&api_requested_module)) {
        isolate->PromoteScheduledException();
        return false;
      }
    } else {
      if (!callback_without_import_assertions(
               context, v8::Utils::ToLocal(specifier),
               v8::Utils::ToLocal(Handle<Module>::cast(module)))
               .ToLocal(&api_requested_module)) {
        isolate->PromoteScheduledException();
        return false;
      }
                ...
```

PrepareInstantiate 함수 역할이 뭔지, callback이 뭐하는 앤지, callback_without_import_assertions이 뭐하는 앤지 모르겠다. 당장은 이해하기 어려움... TODO

```cpp
src/objects/synthetic-module.cc
MaybeHandle<Object> SyntheticModule::Evaluate(Isolate* isolate,
                                              Handle<SyntheticModule> module) {
                ...
  if (!evaluation_steps(
           Utils::ToLocal(Handle<Context>::cast(isolate->native_context())),
           Utils::ToLocal(Handle<Module>::cast(module)))
           .ToLocal(&result)) {
    isolate->PromoteScheduledException();
    Module::RecordErrorUsingPendingException(isolate, module);
    return MaybeHandle<Object>();
  }
                ...
```

이 코드도 역할을 잘 모르겠음. 당장은 이해하기 어려움... TODO

```cpp
RUNTIME_FUNCTION(Runtime_PromoteScheduledException) {
  SealHandleScope shs(isolate);
  DCHECK_EQ(0, args.length());
  return isolate->PromoteScheduledException();
}
```

runtime 함수도 있네... 어떻게 써먹지? ㅋㅋ

PromoteScheduledException 얘는 has_scheduled_exception() 안붙어있는 애들은 위에 언급한 애들이 전부인 듯. 다 훑어보자. 


### scheduled_exception()

scheduled_exception() 호출 전에 has_scheduled_exception() 으로 검증하지 않아야 할 듯.

찾아봤는데 PromoteScheduledException 관련 외에는 모두 has_scheduled_exception()을 거치는 듯.


### etc

```cpp
void Isolate::clear_pending_message() {
  set_pending_message(ReadOnlyRoots(this).the_hole_value());
}
```

얘도 참고하자. (얘는 IteratorCloseOnException 관련하여)

```cpp
src/execution/isolate.cc
void Isolate::RestorePendingMessageFromTryCatch(v8::TryCatch* handler) {
  DCHECK(handler == try_catch_handler());
  DCHECK(handler->HasCaught());
  DCHECK(handler->rethrow_);
  DCHECK(handler->capture_message_);
  Object message(reinterpret_cast<Address>(handler->message_obj_));
  DCHECK(message.IsJSMessageObject() || message.IsTheHole(this));
  set_pending_message(message);
}
```

이런 코드들을 보면 애초에 message는 TheHole이어도 된다고 가정하고 코딩한 듯 하다. 그 얘기는, 결국 TheHole값이 정상적으로 필터링 될 것임을 의미하는 것인가...

---


## v8:12439

```cpp
src/builtins/builtins-temporal-gen.cc
TNode<FixedArray>
TemporalBuiltinsAssembler::TemporalInstantFixedArrayFromIterable(
    TNode<Context> context, TNode<Object> iterable) {
            ...
      BIND(&if_exception);
      IteratorCloseOnException(context, iterator_record);
      CallRuntime(Runtime::kReThrow, context, var_exception.value());
      Unreachable();
            ...
```

IteratorCloseOnException + Runtime::kReThrow 조합인데? builtins-temporal-gen.cc 는 bug:v8:12439 때 없던 파일임. 이거 많이 수상한데...

https://chromium.googlesource.com/v8/v8/+blame/8b663818fc311217c2cdaaab935f020578bfb7a8/src/builtins/builtins-temporal-gen.cc

2022-01-06 에 추가됨(v8:12439는 2021-11-27, commit은 2021-12-06)

이건 지금 바로 봐야겠다.

### IteratorCloseOnException

patchset 1 을 보면 src/builtins/iterator.tq 내 IteratorCloseOnException 에서 ~~Pending Message 관련 처리가 이미 추가되었음... 따라서 이미 패치가 된 것으로 봐야 할 수도. :(~~

patchset 1 에서 추가되었다가 피드백을 받아 변경되었음. 꼼꼼히 보자.

힌트를 얻기 위해서 commit message 등을 보고 있는데... 

1. (from v8:12439)
> We currently don't do that. So when Isolate::pending_message is being cleared or overwritten by an unrelated exception inside of JS code called from IteratorCloseOnException, it can result in the original exception being combined with an unrelated message or TheHole.


2. (from patchset 1)
> [builtins] IteratorCloseOnException needs to preserve the pending message

pending message를 백업해두지 않으면 IterateCloseOnException 내에서 임의 js 수행 시 pending exception + pending message 가 overwritten 될 수 있으므로 이를 고려하여 pending message를 보존해두어야 한다는 의미.

IterateCloseOnException 내에서 임의 js 실행, 다른 Exception 발생(+ 그 exception이 message를 TheHole로 설정하는 경우를 찾아야 함?)

message가 TheHole일 경우 유저에게 TheHole이 leak 되는지 확인 필요(즉, 정말 보안 이슈가 있는지, 아니면 단순 메시지 출력의 오류일 뿐인지 확인 필요)

`SetPendingMessage(TheHole);`를 이미 쓰고 있는 것을 보아... TheHole이 leak되는 경우는 없는 것 같기도 하다... 쩝.

참고: GetAndResetPendingMessage도 v8:12439 에서 추가됨 

```cpp
src/codegen/code-stub-assembler.cc
TNode<HeapObject> CodeStubAssembler::GetPendingMessage() {
  TNode<ExternalReference> pending_message = ExternalConstant(
      ExternalReference::address_of_pending_message(isolate()));
  return UncheckedCast<HeapObject>(LoadFullTagged(pending_message));
}
void CodeStubAssembler::SetPendingMessage(TNode<HeapObject> message) {
  CSA_DCHECK(this, Word32Or(IsTheHole(message),
                            InstanceTypeEqual(LoadInstanceType(message),
                                              JS_MESSAGE_OBJECT_TYPE)));
  TNode<ExternalReference> pending_message = ExternalConstant(
      ExternalReference::address_of_pending_message(isolate()));
  StoreFullTaggedNoWriteBarrier(pending_message, message);
}
```

위와 같이 GetPendingMessage, SetPendingMessage 가 v8:12439에서 추가됨.





